                1月13日
Python用#来进行行注释
用
'''文字'''
或者
"""文字"""
来进行多行注释

print()函数用""或''直接输出字符串

print直接写表达式会得出结果
print('文字',表达式)
print('文字'+表达式)    注意表达式要转换为字符串格式才能用"+"链接

不用定义数据类型，Python自带字符串类型

变量重新赋值后地址会改变

布尔类型输出为True或False
--------------------------------------------------------------------------------------------------
                1月14日
用input函数输入后变量为字符串类型，需要类型转换，否则为对字符进行处理，而非对数据进行处理

运算符除了加减乘除还有幂运算，取余，整除（注意负数的取余有特殊公式）

赋值运算可以解包赋值eg：a,b,c=1,2,3
交换两个数也无需引入第三个变量eg:a,b=1,2    a,b=b,a

比较运算比c语言多了地址比较
"is"  "is not"

布尔运算也就是逻辑运算
"and"=且   "or"=或    "not"=非  "in"=某元素在哪里   "not in"=某元素不在哪里
--------------------------------------------------------------------------------------------------
                1月15日
条件语句
if 条件:
    在此条件下的执行语句
    高度重视缩进Python用缩进代表{}
slif 条件:
    执行语句
else:
    需要执行的语句
条件判断可以写成10<=x<=100

pass语句占位，没有效果

range(begin,end,step)函数创建从begin到end(不包含end)之间的数，步长为step

while 条件：
    执行语句

for 变量 in 可迭代对象：
从 可迭代对象 中的内容依次取出内容赋值给 变量

for _ in range(x)
    需要执行的语句
用此语句可以循环x次
--------------------------------------------------------------------------------------------------
                1月16日
for 变量 in range(x):
    执行语句
else
    执行语句
当循环结束后执行else的语句，并且没有遇到break语句

while 条件:
    执行语句
else
    执行语句
while结束后执行else的语句，并且没有遇到break语句

print('文字',end='')
end是为了不换行输出

列表=数组
列表可以存储不同类型的值
运用了二重指针，一重指针指向一个存着对应值的指针，即二重指针，二重指针指向对应值
字符用'文字'或"文字"括起来
--------------------------------------------------------------------------------------------------
                1月18日
列表定义：
{
    列表名=[值1,值2,值3,...值n,]
    列表名=list([值1,值2,值3,...值n,])
}
列表查找：.index
{
    列表名称.index('查找对象',start,end+1)
    在列表的start到end之间查找对象是否存在
}

列表输出：
    单个：
    {
        逆向输出单个，从最后一个开始引用[-N,-1]
        正向输出单个[0,N-1]
    }
    多个：
    {
        正向输出多个：列表名[start,stop,step],从start开始到stop结束,步长为step
        逆向输出多个,语法与上行基本一致
    }

给列表添加对象：
{
    1.在末尾添加一个对象-->append
        语法:列表名称.append(值),如果是字符串记得加'文字'
        ps如果是原列表.append(列表名),把原列表作为一个元素添加到原列表末尾

    2.在末尾添加多个对象-->extend
        语法:列表名称.extend(值)

    3.在列表任意位置添加元素-->insert
        语法:列表名.insert(x,值),在x处添加值，并且把原来的值全部后移

    4.切片-->列表1[a:b]=列表2,把列表1从a到b替换为列表2
}

可迭代对象:字符串，列表
--------------------------------------------------------------------------------------------------
                1月19日
列表元素的删除
    1.删除某个元素-->remove
        注意,每运行一次只删除一个元素
        有重复只删除最先出现的元素
        语法:列表名称.remove(值)

    2.删除某个位置的元素-->pop
        语法:列表名称.pop(x)
        删除下标为x的元素
        不指定位置,默认删除最后一个元素

    3.切片
        语法:原列表=[start,end]=[]
        把原列表从start到end的值删除
        语法:新列表=原列表[start,end]
        把原列表从start到end的值赋给新列表

    4.清空
        语法:列表名.clear()

    5.删除
        语法:del 列表名

列表元素的修改
    1.修改某个元素
        语法:列表名称[x]=值
        把位于x的原来的值改为新的值

    2.修改多个元素
        语法:列表名称[start:end+1]=[值1,值2,值3,...值n]
        把列表中从start到end的值改为：值1,值2,值3,...值n    PS:数目可以不相等

列表的排序
    1.调用库函数sort()、reverse=True/False
    语法:列表名.sort(reverse=True/False)
        当reverse=True时,为降序排序
        当reverse=False时,为降序升序
        当不写reverse时,默认为升序
        PS该函数是在原列表内重新排序

    2.调用库函数sorted()、reverse=True/False
        语法:新列表名=sorted(原列表,reverse=True/False)
        原列表不变，把 原列表 排序后的值赋给 新列表

列表的生成
    列表名=[表达式 for 自定义变量 in range (start,end+1)]
    从start到end把变量按照表达式计算的值赋值到列表
--------------------------------------------------------------------------------------------------
                1月20日
字典
元素名称不能重复，如果重复前面的值会被后面同名称的值覆盖
元素的值可以重复

定义：字典名{'元素1名称':元素1值,'元素2名称':元素2值,......'元素n名称':元素n值,}
引用：
    {
        方法1：字典名.['元素名称']，如果不存在返回报错
        方法2：字典名.get('元素名称')，如果不存在返回None

        如果查找对象不存在可以指定返回的值
        语法：字典名.get('元素名称',返回值)
    }

删除：
    {
        方法1：del
            del 字典名.['元素名称']
        方法2：clear
            字典名.clear()
    }

添加：
    字典名['新元素名称']=值

修改：
    字典名['元素名称']=新值

获取字典的值
{
    1.只获取元素名称 .keys()
    语法：变量名称=字典名称.keys()

    2.只获取元素值 .values()
    语法：变量名称=字典名称.values()

    3.获取字典元素名称及其对应的值 .items()
    语法：变量名称=字典名称.items()
}

字典生成
语法：
元素名称的列表[元素名称1,元素名称2,.....,元素名称n]
元素值的列表[元素的值1,元素的值2,.....,元素的值n]
字典名称={元素名称:值的名称   for 元素名称,值的名称 in zip(元素名称的列表,元素值的列表)}
PS：如果两个列表数目不一样，按照数目小的那个生成字典
--------------------------------------------------------------------------------------------------
                1月21日
元组
定义：
{
    方法1：元组名=(值1,值2,...,值n)

    方法2：元组名=tuple((值1,值2,...,值n))
    注意：如果只有一个元组的值，必须要加逗号 “,”，否则类型为字符串类型
}
不允许修改对象，除非是对元组中的列表的值进行修改

集合
定义：
{
    方法1：集合名={字典，元组，列表，另一个集合，字符串}

    方法2：集合名=set(字典，元组，列表，另一个集合，字符串)   
}
集合内的值不能存在相同的，有相同的会自动去除
集合值的储存是无序的
定义空集合用set()函数

用in 或not in 函数来判断集合中是否存在某个数

添加
{
    方法1：add
    {
        语法：集合名.add(值)
    }

    方法2：update
    {
        语法：集合名.update(字典，元组，列表，另一个集合，字符串)
        可以添加多个元素
    }
}

删除
{
    方法1：.remove()
    {
        语法：集合名.remove(值)
        如果值不存在，会返回error
    }

    方法2：.discard(值)
    {
        语法：集合名.discard(值)
        即使值不存在，也不会返回error
    }

    方法3：.pop()
    {
        语法：集合名.pop()
        随机删除一个值
    }

    方法4：.clear()
    {
        语法：集合名.clear()
        将集合的值清空
    }
}

判断集合之间的关系：
1：
{
    ==和!=
    判断两个集合是否相等
}
2：
{
    集合1.issbuset(集合2)
    集合1是否是集合2的子集

    集合1.issuperset(集合2)
    集合1是否是集合2的超集合

    集合1.isdisjoint(集合2)
    集合1和集合2是否有交集
}

集合之间的运算：
交集：
{
    集合1.intersection(集合2)
    集合1 & 集合2
    求集合1与集合2的交集
}
并集：
{
    集合1.union(集合2)
    集合1 | 集合2
    求集合1与集合2的并集
}
差集：
{
    集合1.difference(集合2)
    集合1-集合2
    求集合1比集合2多的元素
}
对称差集：
{
    集合1.symmetric_difference(集合2)
    集合1^集合2
    求 集合1和集合2的并集 去除 集合1和集合2的交集 剩下的元素
}

集合的生成：
集合名={表达式 for 自定义变量 in 可迭代对象}
--------------------------------------------------------------------------------------------------
                1月22日
字符串
定义：
字符串名称=('字符串')

查询：
{
    方法1：.index('')
        语法：字符串名称.index('字符串')
        查找字符串第一次出现的位置
        字符串不存在会报错

    方法2：.find('')
        语法：字符串名称.find('字符串')
        查找字符串第一次出现的位置

    方法3：.rindex('')
        语法：字符串名称.rindex('字符串')
        查找字符串最后一次出现的位置
        字符串不存在会报错

    方法4：.rfind('')
        语法：字符串名称.rfind('字符串')
        查找字符串最后一次出现的位置
}

大小写转换：
{
    方法1：.upper()
    语法：
    {
        新字符串=原字符串.upper()
        print(原字符串.upper())
    }
    全部转换成大写

    方法2：.lower()
    语法：
    {
        新字符串=原字符串.lower()
        print(原字符串.lower())
    }
    全部转换成小写

    方法3：.swapcase()
    语法：
    {
        新字符串=原字符串.swapcase()
        print(原字符串.swapcase())
    }
    把大写的转成小写，小写转成大写

    方法4：.capitaize()
    语法：
    {
        新字符串=原字符串.capitalize()
        print(原字符串.capitalize())
    }
    把第一个字符转成大小，其他转成小写

    方法5：.title()
    语法：
    {
        新字符串=原字符串.title()
        print(原字符串.title())
    }
    把每个单词的第一个转成大写，其他转成小写
}

对齐：
{
    居中：.center(长度,'填充字符')
    语法：
    {
        新字符串=原字符串.center(长度,'填充字符')
        print(原字符串.center(长度,'填充字符'))
    }

    左对齐：.ljust(长度,'填充字符')
    语法：
    {
        新字符串=原字符串.ljust(长度,'填充字符')
        print(原字符串.ljust(长度,'填充字符'))
    }

    右对齐
    方法1：.rjust()
    语法：
    {
        新字符串=原字符串.rljust(长度,'填充字符')
        print(原字符串.rjust(长度,'填充字符'))
    }

    方法2：.zfill()
    {
        新字符串=原字符串.zfill(长度)
        print(原字符串.rjust(长度)
    }
    用0来填充

    不写填充符默认是空格
}

拆分：
{
    左拆分：字符串.split(sep='拆分字符',maxsplit=数字)
    拆分字符可以不写，默认以空格进行拆分
    数字可以不写，写了表示拆分几次，默认全部拆分

    右拆分：字符串.rsplit(sep='拆分字符')
    拆分字符可以不写，默认以空格进行拆分
    数字可以不写，写了表示拆分几次，默认全部拆分
}
--------------------------------------------------------------------------------------------------
                1月23日
字符串的判断：
{
    判断字符串是不是合法的标识符和中文：.isidentifier()
    '字符串'或字符串名称.isidentifier()
    合法标识符：字母、数字、下划线

    判断字符串是不是由空字符串组成：.isspace()
    '字符串'或字符串名称.isspace()
    空字符串：回车、换行、水平制表符

    判断字符串是否全部由字母组成：.isalpha()
    字符串或字符串名称.isalpha()
    在Python中中文也会被判断成字母

    判断字符串是否由十进制数字组成：.isdecimal()
    '字符串'或字符串名称.isdecimal()

    判断字符串是否由数字组成：.isnumeric()
    '字符串'或字符串名称.isnumeric()
    Python中中文的、罗马的数字也被判断成数字eg：一二三四；I、II

    判断字符串是否由字母数字组成：
    '字符串'或字符串名称.isalnum()
    Python中的字母包括中文，数字包括中午数字和罗马数字
}

字符串的替换：.replace()
'字符串'或字符串名称.replace('被替换内容','替换的内容',替换次数)
如果有多个相同的内容，可以控制替换次数，默认全部替换

字符串的连接：.join()
'连接字符'.join(列表、元组或'字符串')

字符串的比较：<,>,<=,>=,==,!=
--------------------------------------------------------------------------------------------------
                1月24日
{
    字符串的比较是从第一个字符开始比较，直到发现某个字符满足条件就停止比较
    {
        apples < application
        e < i 结果是真，直接停止不再进行比较
    }
}

字符串的切片：
语法：字符串[begin:end+1;step]
{
    从begin到end以step为步长获取字符串的字符
}
目标字符串=字符串1[begin:end+1;step]+字符串2[begin:end+1;step]+...+字符串n[begin:end+1;step]
以此来对字符串进行切片并创建一个新的字符串

格式化字符串的输出：
    方法1：
    {
        '%'型：
        print('%d %s %f' %(整形变量名,字符串变量名,浮点变量名))
    }

    方法2：
    {
        f-string型：
        print(f'{变量名}文字 {变量名}文字...{变量名}文字')
    }

    方法3：
    {
        .format()型
        print('{索引} {索引} {索引}'.format(变量名1,变量名1))
        PS索引按照变量名的顺序从零开始写阿拉伯数字
    }

字符串的编码与解码：
{
    编码：.encode(encoding='编码')
    新字符串=字符串名称.encode(encoding='编码')

    解码：.decode(encoding='编码')
    新字符串=字符串名称.decode(encoding='编码')
}

函数的定义：
{
def 函数名(输入参数):
    函数体
    [return x,x]
函数定义时可以设置参数的初始值
}

函数调用：
{
    参数的传递
    def 函数名(参数1,参数2):
    方式1：按位置
    {
        函数名(参数1,参数2)
    }
    方式2：按关键字
    {
        函数名(参数1=,参数2=)
    }
}

函数的返回值：
{
    返回值可以是多个
    {
        语法：return x,y,...,z
    }
    如果返回值是多个，类型为元组
    如果返回值是单个，类型为返回值的类型
}

函数的可变参数：
{
    *名字：
    可以往函数中传递任意个变量
    输出结果为元组

    **名字：
    可以往函数中传递任意个关键字
    输出结果为字典
}
--------------------------------------------------------------------------------------------------
                1月25日
局部变量转换为全局变量：gloabl 变量名

递归函数：函数自己调用自己

常见错误：
{
    中英文混用
    赋值号与逻辑判断混用
    缩进错误
    input函数没有进行类型转换
    列表越界
    使用变量时没有定义
    循环语句没有跳出循环的条件
}
异常的处理；
方法1：
{
    try:
        可能出错的代码
    except 错误的类型1:
        处理方法
    except 错误的类型2:
        处理方法
    except 错误的类型n:
        处理方法
}
方法2：
{
    try:
        可能出错的代码
    except BaseException as 变量名:
        处理方法
    else:
        后续代码
    finally:
        无论程序是否正常运行都要运行的代码
        eg：文件指针的消除，开辟的内存空间的清理
}
--------------------------------------------------------------------------------------------------
                1月26日
类：
创建方法：
{
    class 类的名字:
        '''帮助信息'''
        def __init__(self):
            需要运行的代码

    变量名=类的名字()
    此时会直接运行类__init__的方法体

    例如：
    {
        class A:
        def __init__(self,变量1,...,变量n):       //这是第一个方法体
            print("这是一个类")
            对于变量运算的代码

        def 第二个方法体(self,变量1,...,变量n):
            对应的代码
        
        c = A(对应变量1的值,...,对应变量n的值)
        c.第二个方法体(对应变量1的值,...,对应变量n的值)
    }
}
在self后可以继续添加变量，变量之间用","隔开

继承：
{
    class 类的名字(继承的类的名字)
        '''帮助信息'''
        后续代码
    
    例如：
    {
        class Father:
        def father(self):
            print("这是一个父类")

        class Son(Father):
            def __init__(self):
                print("这是一个子类")

    c = Son()
    c.father()
    用"."符号可以调用父类
    用 super().父类的方法体() 可以调用父类的方法体，即使是同名的
    }
}
